// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: member.sql

package db

import (
	"context"
	"database/sql"
)

const listAcceptedMembers = `-- name: ListAcceptedMembers :many
SELECT memberID, fName, lName, email, phone, githubUrl, interest, reason 
FROM MEMBER
WHERE acceptDateTime IS NOT NULL
`

type ListAcceptedMembersRow struct {
	Memberid  int32          `json:"memberid"`
	Fname     string         `json:"fname"`
	Lname     string         `json:"lname"`
	Email     string         `json:"email"`
	Phone     sql.NullString `json:"phone"`
	Githuburl sql.NullString `json:"githuburl"`
	Interest  string         `json:"interest"`
	Reason    string         `json:"reason"`
}

func (q *Queries) ListAcceptedMembers(ctx context.Context) ([]ListAcceptedMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcceptedMembers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAcceptedMembersRow
	for rows.Next() {
		var i ListAcceptedMembersRow
		if err := rows.Scan(
			&i.Memberid,
			&i.Fname,
			&i.Lname,
			&i.Email,
			&i.Phone,
			&i.Githuburl,
			&i.Interest,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMember = `-- name: ListMember :one
SELECT memberID, fName, lName, email, phone, githubUrl, interest, reason 
FROM MEMBER
WHERE memberID = ?
`

type ListMemberRow struct {
	Memberid  int32          `json:"memberid"`
	Fname     string         `json:"fname"`
	Lname     string         `json:"lname"`
	Email     string         `json:"email"`
	Phone     sql.NullString `json:"phone"`
	Githuburl sql.NullString `json:"githuburl"`
	Interest  string         `json:"interest"`
	Reason    string         `json:"reason"`
}

func (q *Queries) ListMember(ctx context.Context, memberid int32) (ListMemberRow, error) {
	row := q.db.QueryRowContext(ctx, listMember, memberid)
	var i ListMemberRow
	err := row.Scan(
		&i.Memberid,
		&i.Fname,
		&i.Lname,
		&i.Email,
		&i.Phone,
		&i.Githuburl,
		&i.Interest,
		&i.Reason,
	)
	return i, err
}

const listMemberByEmail = `-- name: ListMemberByEmail :one
SELECT memberID, fName, lName, email, phone, githubUrl, interest, reason 
FROM MEMBER
WHERE email = ?
`

type ListMemberByEmailRow struct {
	Memberid  int32          `json:"memberid"`
	Fname     string         `json:"fname"`
	Lname     string         `json:"lname"`
	Email     string         `json:"email"`
	Phone     sql.NullString `json:"phone"`
	Githuburl sql.NullString `json:"githuburl"`
	Interest  string         `json:"interest"`
	Reason    string         `json:"reason"`
}

func (q *Queries) ListMemberByEmail(ctx context.Context, email string) (ListMemberByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, listMemberByEmail, email)
	var i ListMemberByEmailRow
	err := row.Scan(
		&i.Memberid,
		&i.Fname,
		&i.Lname,
		&i.Email,
		&i.Phone,
		&i.Githuburl,
		&i.Interest,
		&i.Reason,
	)
	return i, err
}

const listRequestingMembers = `-- name: ListRequestingMembers :many
SELECT memberID, fName, lName, email, phone, githubUrl, interest, reason 
FROM MEMBER
WHERE acceptDateTime IS NULL
`

type ListRequestingMembersRow struct {
	Memberid  int32          `json:"memberid"`
	Fname     string         `json:"fname"`
	Lname     string         `json:"lname"`
	Email     string         `json:"email"`
	Phone     sql.NullString `json:"phone"`
	Githuburl sql.NullString `json:"githuburl"`
	Interest  string         `json:"interest"`
	Reason    string         `json:"reason"`
}

func (q *Queries) ListRequestingMembers(ctx context.Context) ([]ListRequestingMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, listRequestingMembers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRequestingMembersRow
	for rows.Next() {
		var i ListRequestingMembersRow
		if err := rows.Scan(
			&i.Memberid,
			&i.Fname,
			&i.Lname,
			&i.Email,
			&i.Phone,
			&i.Githuburl,
			&i.Interest,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const acceptMember = `-- name: acceptMember :exec
UPDATE MEMBER 
SET acceptDateTime = NOW() 
WHERE memberID = ?
`

func (q *Queries) acceptMember(ctx context.Context, memberid int32) error {
	_, err := q.db.ExecContext(ctx, acceptMember, memberid)
	return err
}

const insertMember = `-- name: insertMember :exec
INSERT INTO MEMBER (fName, lName, email, phone, githubUrl, interest, reason) 
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type insertMemberParams struct {
	Fname     string         `json:"fname"`
	Lname     string         `json:"lname"`
	Email     string         `json:"email"`
	Phone     sql.NullString `json:"phone"`
	Githuburl sql.NullString `json:"githuburl"`
	Interest  string         `json:"interest"`
	Reason    string         `json:"reason"`
}

func (q *Queries) insertMember(ctx context.Context, arg insertMemberParams) error {
	_, err := q.db.ExecContext(ctx, insertMember,
		arg.Fname,
		arg.Lname,
		arg.Email,
		arg.Phone,
		arg.Githuburl,
		arg.Interest,
		arg.Reason,
	)
	return err
}
